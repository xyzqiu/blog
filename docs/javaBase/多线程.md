## 1、线程概述
几乎所有的操作系统都支持同时运行多个任务，一个任务通常就是一个程序，每个运行中的程序就是一个进程。当一个程序运行时，内部可能包含了多个顺序执行流，每个顺序执行流就是一个线程。
### 1.1、线程和进程
进程是系统进行资源分配和调度的一个独立单位。
进程的三个特征：
1. 独立性：进程是系统中独立存在的实体，它可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况下，一个用户进程不可以直接访问其他进程的地址空间
2. 动态性：进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念。进程具有自己的生命周期和各种不同的状态。
3. 并发行：多个进程可以单个处理器上并发执行，多个进程之间不会互相影响。

并发性：在同一时刻只能有一条指令执行。
并行性：同一时刻，有多条指令在多个处理器上同时处理。

==操作系统可以同时执行多个任务，每个任务就是进程；
进程可以同时执行多个任务，每个任务就是线程。==

## 2、线程的创建和启动
### 2.1、继承Thread类来创建线程类
1. 定义Thread类的子类，并重写该类的run()方法。
2. 创建Thread子类的实例，即创建了线程对象。
3. 调用线程对象的start()方法来启动该线程。
### 2.2、实现Runnable接口创建线程类
1. 定义Runnable接口的实现类，并重写该接口的run()方法。
2. 创建Runnable接口实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
3. 调用线程对象的start方法来启动该线程

> 注意：Runnable对象仅仅作为Thread对象的target，Runnable实现类里包括的run方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run方法。

### 2.3、使用Callable和Future创建线程
1. 创建Callable接口的实现类，并实现call()方法，再创建Callable实现类的实例。
2. 使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
3. 使用FutureTask对象作为Thread对象的target创建并启动新线程。
4. 调用FutureTask对象的get()方法来获得之线程执行结束后的返回值。
### 2.4、创建线程的三种方式对比
采用实现Runnable、Callable接口的方式创建多线程的优缺点：
1. 线程类只是实现了Runnable和Callable，还可以继承其他类。
2. 多个线程可以共享一个target对象，适合多个相同线程来处理一份资源的情况。
==劣势是编程稍微复杂，如果需要访问当前线程，则必须使用Thread.currentThread()方法。==

采用继承Thread类的方式创建多线程的优缺点
劣势是：Java单继承的特性，所以他不能再继承其他类。
优势是：编写简单，需要访问当前线程可直接使用this获取。



## 3、线程的生命周期
在线程的生命周期中，他要经过新建（NEW）、就绪（Ready）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态。
### 3.1、新建和就绪状态
1. 当程序使用new关键字创建了一个线程之后，该线程就处于新建状态。
2. 当线程对象调用了start()方法之后，该线程就处于就绪状态。就绪状态只是表明当前线程可以开始运行，并不是运行状态。至于该线程何时开始运行，取决于JVM里线程调度器的调度。
### 3.2、运行和阻塞状态
Running状态
1. 处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态。

Blocked状态
1. 线程调用sleep()方法主动放弃所占用的处理器资源
2. 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞
3. ==线程试图获得一个同步监视器，当该同步监视器正被其他线程所持有。==
4. 线程在等待某个通知（notify）
5. 程序调用了线程的suspend()方法将该线程挂起。

被阻塞的线程阻塞状态结束后会重新进入就绪状态（Ready），等待线程调度器再次调度他。
![[截屏2024-03-21 20.37.02.png]]
### 3.3、线程死亡
线程会以如下三种方式结束：
1. run()或call()方法执行完成，线程正常结束
2. 线程抛出一个未捕获的Exception或Error
3. 直接调用线程stop()方法——该方法容易导致死锁，不推荐。

> 当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，不受主线程的影响。

isAlive()方法：当线程处于就绪、运行、阻塞三种状态时，该方法将返回true；
当线程处于新建、死亡两种状态时，该方法将返回false。

==已死亡的线程如果再调用start()方法和新建状态两次调用start()方法都会引发IllegalThreadStateException异常。==

## 4、控制线程
Java的线程支持提供了一些便捷的工具方法，通过这些便捷的工具方法可以很好的控制线程的执行。

### 4.1、join线程
join()方法：让一个线程等待另一个线程完成。
当某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到被join方法加入join线程执行完为止。

join方法通常由使用线程的程序调用，以将大问题划分为许多小问题，每个小问题分配一个线程。当所有的小问题都得到处理后，再调用主线程来进一步操作。

join()方法有如下三种重载形式
1. join()：等待被join的线程执行完成。
2. join(long millis):等待被join最长时间为millis毫秒。
3. join(long millis,int nanos):nanos毫微秒（操作系统无法精确到毫微秒）

### 4.2、后台线程
后台线程（Daemon Thread）：在后台运行的线程，它的任务是为其他线程提供服务。又称为”守护线程“或”精灵线程“。JVM的垃圾回收线程就是典型的后台线程。
特征：如果所有的前台线程都死亡，后台线程会自动死亡。

调用Thread对象的setDaemon(true)方法设置成后台线程。当整个虚拟机中只剩下后台线程，程序没有继续运行的必要了，所以虚拟机也就退出了。

==setDaemon(true)需要在start()之前，否则引发IllegalThreadStateException异常。==

### 4.3、线程睡眠
如果需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread类的静态sleep()方法来实现。sleep()方法有两种重载形式：
1. static void sleep(long millis)；让当前正在执行的线程暂停millis毫秒，并进入阻塞状态
2. static void sleep(long millis, int nanos): 精度nanos毫微秒，基本用不上。
调用sleep方法进入阻塞状态，在其睡眠时间内该线程不会获得执行的机会。

此外，Thread还提供了一个与sleep方法类似的yield()静态方法，它也可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程转入就绪状态。

### 4.4、改变线程优先级
每个线程默认的优先级都与创建它的父线程优先级相同，在默认情况下，main线程具有普通优先级，由main线程创建的之线程也具有普通优先级。

Thread类提供了setPriority(int newPriority)、getPriority()方法来设置和返回指定线程的优先级，setPriority()方法的阐述可以是一个整数，范围时1～10之间，也可以用Thread的几个常量：
MAX_PRIORITY： 10
MIN_PRIORITY：1
NORM_PRIORITY：5

## 5、线程同步
当多个线程来访问同一个数据时，很容易出现线程安全问题。
### 5.1、线程安全问题

多个线程去操作一个共享数据，可能会出现与预期结果不一致的情况。
两个并发线程同时操作一个数据，在线程A对数据进行修改时，处理器资源切换给线程B进行修改。两个线程都修改成功了，这就是线程不安全。

>两个线程并发修改同一个文件时就有可能造成异常。

### 5.2、同步代码块
```java 
synchronized(obj){
	...//此处的代码就是同步代码块
}
```
作用：阻止两个线程对同一个共享资源进行并发访问。即两个线程对同一资源同时进行访问。
注意：任何时刻只能有一个线程可以获得synchronized的锁定，当同步代码块执行完之后，该线程会释放synhronized的锁的。

任何线程在修改指定资源时， 首先对该资源进行加锁，在加锁期间其他线程无法修改资源，当该线程修改完成后，该线程释放对该资源的锁定。通过这种方式保证任一时刻内只有一个线程可以进入修改共享资源的代码区（临界区）。即同一时刻只有一个线程在临界区内，就保证了线程安全。

### 5.3、同步方法
使用synchronized关键字来修饰某个方法，则该方法称为同步方法。同步方法无需要显式的指定同步监视器，同步方法的同步监视器就是this，就是调用同步方法的对象。
```Java
public synchronized void test(){}
```

当线程A通过Account对象调用同步方法test()，此时同步监视器为Account对象，进行加锁操作，运行同步方法期间，线程B也通过Account对象调用test()方法，此时线程B处于阻塞状态，等待线程A释放锁。 

### 5.4、释放同步监视器的锁定
任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定。何时会释放同步监视器的锁定？
1. 当前线程的同步方法、同步代码块执行结束
2. 当前线程在同步代码块中遇到break、return中字了该代码块、该方法的继续执行。
3. 当前线程在同步代码块、同步方法出现了未处理的Error、Exception，导致了该代码块、该方法异常结束时
4. 当前线程执行同步代码块或同步方法时，程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器。

如下情况，线程不会是释放同步 监视器。
1. 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法来涨停当前线程的执行
2. 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起。

### 5.5、同步锁（Lock）
从Java 1.5开始，Java提供了一种更强大的线程同步机制——通过显式定义同步说对象来实现同步，这种机制下，同步锁由Lock对象充当。
Lock是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。


提供了两个接口Lock、ReadWriteLock，并为Lock提供了ReentrantLock（可重入锁）的实现类，为ReadWriteLock提供了ReentrantReadWriteLock实现类。

比较常用的是ReentrantLock（可重入锁）。使用该Lock对象可以显式地加锁、释放锁。
使用ReentrantLock代码格式如下：
```java
class X
{
	//定义锁对象
	private final ReentrantLock = new ReentrantLock();
	//..
	//定义需要保证线程安全的方法
	pubulic void m(){
		//加锁
		lock.lock();
		try{
			//需要保证线程安全的代码
			//...method body
		}
		//使用finally块来保证释放锁
		finally{
		  lock.unlock();
		}
	}
}
```
使用ReentrantLock对象来进行同步，加锁和释放锁出现在不同的作用范围内时，通常建议使用finally块来确保在必要时释放锁。

ReentrantLock锁具有可重入性，也就是说，一个线程可以对已被加锁的ReentrantLock锁再次加锁，ReentrantLock对象会维持一个计数器来追踪lock()方法的嵌套调用，线程在每次调用lock()加锁后，必须显式调用unlock()来释放锁，所以==一段被锁保护的代码可以调用另一个被相同锁保护的方法==

### 5.6、死锁及常用处理策略
==当两个线程相互等待对方释放同步监视器时就会发生死锁==，Java虚拟机没有检测，也没有采取措施来处理死锁情况，所以多线程编程时应该采取措施避免死锁出现。

常见方式避免死锁：
1. 避免多次锁定：尽量避免同一个线程对多个同步监视器进行锁定。
2. 具有相同的加锁顺序 ：如果多个线程需要对多个同步监视器进行锁定，则应该保证它们以相同的顺序请求加锁。
3. 使用定时锁：程序调用Lock对象的tryLock()方法加锁时，可以指定time和unit参数，当超过指定时间后会自动释放对Lock的锁定，这样就可以解开死锁了。
4. 死锁检测：依靠算法来实现的死锁预防机制，它主要针对那些不可能实现按序加锁，也不能使用定时锁的场景。

## 6、线程通信
程序通常无法准确控制线程的轮换执行，但是Java也提供了一些机制来保证线程协调运行。

### 6.1、传统的线程通信
使用Object类的wait()、notify()、notifyAll()。这三个方法必须由同步监视器对象来调用，可以分为以下两种情况。
1. 对于使用synchronized修饰的同步方法，因为该类的默认实例（this）就是同步监视器，所以可以在同步方法中直接调用这三个方法。
2. 对于使用synchronized修饰的同步代码块，同步监视器是sychronized后括号的对象，所以必须使用该对象调用这三个方法。

1. wait()：导致当前线程等待，直到其他线程调用该同步监视器的notify()方法或者notifyAll()方法来唤醒该线程。
2.  notify()：唤醒再次同步监视器上等待的单个线程。如果所有线程都在此同步监视器上等待，则会选择唤醒其中一个，选择是任意的。只有当前线程放弃对该同步监视器的锁定后（使用wait()方法），才可以执行被唤醒的线程。 
3. notifyAll()：唤醒在此同步监视器上所有等待的线程。

### 6.2、使用Condition控制线程通信
当使用Lock对象来保证同步时，Java提供了一个Condition类来保持协调，使用Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象，Condition对象也可以唤醒其他处于等待的线程。
lock.newCondition()获得Lock实例的Condition实例。
Condition提供了如下三个方法：
1. await():类似隐式同步监视器的wait()方法，导致当前线程等待，直到其他线程调用singnal()、singnalAll()方法唤醒该线程。
2. signal()：唤醒在此Lock对象上等待的当个线程
3. signalAll()：唤醒在此Lock对象上等待的所有线程。

### 6.3、使用阻塞队列（BlockingQueue）控制线程通信
特征：当生产者线程试图向 BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue取出元素时，如果该队列已空，则该线程被阻塞。

## 7、线程组和未处理的异常

## 8、线程池
系统启动一个线程的成本是比较高的，因为它涉及与操作系统交互。在这种情形下，使用线程池可以很好提高性能。

与数据库连接池类似的事，线程池在系统启动时即创建大量生存期很短暂的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会启动一个空闲的线程来执行它们的run()或call()方法，当方法执行完后，该线程并不会死亡，而是再次返回线程池中称为空闲状态，等待执行下一个run()或call()方法。

### 8.1、使用线程池管理线程
Executors工厂类生产线程池，该工厂类包含几个静态工厂方法来创建线程池。
1. newCachedThreadPool()：创建一个具有缓存功能的线程池
2. newFixedThreadPool(int nThreads)：创建一个可重用的、具有固定线程数的线程池
3. newSingleThreadExecutor()：创建一个只有单线程的线程池
这三个方法返回一个ExecutorService对象，该对象代表一个线程池，它可以执行Runnable或Callable对象所代表的线程；

ExecutorService提供了三个方法：
1. Future < ? >  submit(Runnable task)：将一个Runnable对象提交给指定的线程池
2. < T >Future< T > submit(Runnable task, T result)：
3. < T >Future< T > submit(Callable < T >  task)

用完一个线程池后，应该调用该线程池的shutdown()方法，该方法将启动线程池的关闭序列，调用shutdown()方法后的线程池不在接受新任务，但会讲以前所有提交任务执行完成。

#### 使用线程池来执行线程任务的步骤
1. 调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池。
2. 创建Runnable实现类或Callable实现类的实例，作为线程任务
3. 调用ExecutorService对象 的submit()方法来提交Runnable实例或Callable实例。
4. 当不想提交任何任务时，调用ExecutorService对象的shutdown方法来关闭线程池。

## 8.2、使用ForkJoinPool利用多CPU

## 9、线程安全相关类
Java还为线程安全提供了一些工具类，入ThreadLocal类，它代表一个线程局部变量，通过把数据放在ThreadLocal中就可以让每个线程创建一个该变量的副本，从而避免并发访问的线程安全问题。

### 9.1、ThreadLocal
ThreadLocal 是Thread Local Variable（线程局部变量）的意思。
功能：为每一个使用该变量的线程都提供一个变量值的副本，使每一个线程都可以独立的改变自己的副本，而不会和其他线程的副本冲突。

它只提供了如下三个public方法：
1. T get()：返回此线程局部变量中当前线程副本中的值。
2. void removed()：删除此线程局部变量中当前线程的值。
3. void set(T value)：设置此线程局部变量中当前线程副本中的值

ThreadLocal和其他所有同步机制一样，都是为了解决多线程中对同一变量的访问冲突。ThreadLocal从另一个角度来解决多线程的并发访问，ThreadLocal将需要并发访问的资源复制多份，每个线程拥有一份资源，每个线程都拥有自己的资源副本，从而也就没有必要对该变量进行同步了。

> 如果多个线程之间需要共享资源，以达到线程之间通信的功能，就使用同步机制；如果仅仅需要隔离多个线程之间的共享冲突，则可以使用ThreadLocal

### 9.2、包装线程不安全的集合
ArrayList、LinkedList、HashList、TreeSet、HashMap、TreeMap等都是线程不安全的。
如果多个线程访问以上集合，可食用Collections提供的类方法把这些集合包装成线程安全的集合。Collections提供了一下几个静态方法：
1. < T > Collection < T > synchronizedCollection(Collection< T > c)：返回指定collection对应的线程安全的collection。
2. static < T > List < T > synchronizedList(List < T > list)：返回指定List对象对应的线程安全的List对象。
3. static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)
4. static < T > Set< T > synchronizedSet(Set< T > s)

使用Collections的synchronizedMap方法将一个普通的HashMap包装成线程安全的类。
```java
HashMap m = Collections.synchronizedMap(new HashMap());
```

### 9.3、线程安全的集合类
ConcurrentHashMap








