mysql 是如何保证原子性的？
1、undo log 名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的SQL语句，他需要记录你要回滚的相应日志信息。
例如：
- 当你要delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
- 当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，就根据旧值执行update操作。
- 当你insert一条数据的时候，就需要记录这条数据的主键，回滚的时候，根据主键执行delete操作。
undo log 记录了这些需要回滚的数据，当事务执行失败或调用rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

undo log 解析
1、Undo Log是InnoDB十分重要的组成部分，它的作用横贯InnoDB中最主要的部分，并发控制（Concurrency Control）和故障恢复（Crash Recovery）,InnoDB中Undo Log 的实现亦日志亦数据。

undo log用来记录每次修改之前的历史值，配合Redo log用于故障恢复。这也是InnoDB中Undo log的第一个作用。

数据库实现中通常会在正常事务进行中，就不断的连续写入Undo Log,来记录本次修改之前的历史值。当Crash真正发生时，可以在Recovery过程中通过回放Undo Log 将未提及事务的修改抹掉。

2、MVCC（Multi-Version Concurrency Control）
为了避免只读事务与写事务之间的冲突，避免写操作等待读操作，几乎所有的主流数据库都采用了多版本并发控制（MVCC）的方式，也就是为每条记录保存多份历史数据供事务访问，新的写入只需要添加新的版本即可，无需等待。InnoDB 在这里复用了Undo Log 中已经记录的历史版本数据来满足MVCC的需求。

**什么样的Undo Log**
InnDB用Undo Log来实现MVCC,DB运行过程中是允许有历史版本的数据存在的，因此，Crash Recovery时利用Undo Log的事务回滚完全可以在后台，像正常运行的事务一样异步回滚，从而让数据库先恢复服务。因此，Undo Log的设计思路完全不同于Redo Log ,Undo Log需要的是事务之间的并发，以及方便的多版本数据维护，其重放逻辑不希望因DB的物理存储变化而变化，因此，InnoDB中的Undo Log采用了基于事务的Logical Logging的方式。

同时，更多的责任意味着更复杂的管理逻辑，InnoDB中其实是把Undo当作一种数据来维护和使用的，也就是说，Undo Log日志本身也像其他的数据库数据一样，会写自己对应的Redo Log，通过Redo Log来保证自己的原子性。因此，更适合的称呼应该是Undo Data。

**Undo Record中的内容**
每当InnoDB中需要修改某个Record时，都会将其历史版本写入一个Undo Log 中，对应的Undo Record是UPdate类型。当插入新的record是，还没有一个历史版本，但为了方便事务回滚时做逆向（delete）操作，这里还是会写入一个insert类型的Undo Record。

mysql是如何保证持久性的？

mysql是先把磁盘上的数据加载到内存，在内存中对数据进行修改，再刷回磁盘上。如果此时电脑宕机，内存中的数据就会丢失。如果在事务提交就直接将数据写入磁盘，会太浪费资源，如果只修改一个页面里的一个字节，就要将整个页面刷入磁盘，一个页面就16kb大小。而且一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是随机IO。显然操作随机IO，速度会比较慢。

采用redo log解决上面的问题。当数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘（redo log 一部分在内存中，一部分在磁盘上）。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log 和binlog 内容决定回滚数据还是提及数据。 


# 使用多核CPU实现读取优化数据库的快速更新

HYRISE是一个内存压缩的虚拟分区数据库引擎。旨在支持混合工作负载所需的更新率，并提供列存储的高读取性能。表在物理上存储为属性和元数据的集合。每个属性由两个分区组成：main分区和delta分区。

主分区是字典压缩的——元组中的值由字典中的编码值替换。有序集合用作字典，允许按排序顺序快速迭代元组。此外，搜索操作可以实现为具有对数复杂度的二进制搜索。因此，大多数查询都可以通过字典中的二进制搜索（随机访问）来执行，同时只扫描列（顺序访问）中的编码值。这是有代价的：更新可能会更改编码值，并需要重写整个分区。因此，在主分区中直接更新的速度是不可接受的缓慢。










