Java集合大致可分为Set、List、Queue、Map四种体系。
Set：无序，不可重复的集合；
List：有序、重复的集合
Queue：队列集合实现
Map：有映射关系的集合

# 1、Set 集合

Set接口的实现类：HashSet、SortSet、EnumSet

## 1.1、HashSet类
HashSet按照Hash算法来存储集合中的元素，因此具有很好的==存取和查找性能==
特点：
1. 无序的，不保证排列顺序，顺序也可能发生变化
2. HashSet是不同步的，多个线程同时访问一个HashSet需要通过代码来保证其同步
3. 集合元素值可以是null
> 当向hashSet集合中存入一个元素时，HashSet会调用该对象的HashCode()方法来得到该对象的HashCode值，然后根据该hashCode值决定该对象在HashSet中的存储位置。如果有两个元素通过equals()比较返回true，但是hashCode()方法返回值不想等，hashSet将会把它们存储在不同的位置，依然可以添加成功。

## 1.2、LinkedHashSet类
HashSet子类：LinkedHashSet；LinkedHashSet也是根据元素的hashCode值来决定元素的存储位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。也就是说，当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。

> LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet，但是在迭代访问Set里的全部元素将有很好的性能，因为它以链表来维护内部顺序。

## 1.3、TreeSet类
TreeSet是SortedSet接口的实现类，正如SortedSet名字所暗示的，TreeSet可以确保集合元素处于排序状态。与HashSet相比，TreeSet额外提供了几个方法：
1. Comparator comparator()：如果TreeSet采用了定制排序，则该方法返回定制排序所使用的Comparator；如果TreeSet采用自然排序，则返回null；
2. Object first()：返回集合中的第一个元素
3. Object last()：返回集合中的最后一个元素。
4. Object lower(Object e)：返回集合中位于指定元素之前的元素
5. Object higher(Object e)：返回集合中位于指定元素之后的元素
6. SortedSet subSet(Object fromElement, Object toElement)：返回次Set的子集合，范围从fromElement（包含）到toElement(不包含)

> TreeSet是根据元素实际值的大小来进行排序的，与HashSet集合采用hash算法来决定元素的存储位置不同，TreeSet采用红黑树的数据结构来存储集合元素的。
> TreeSet支持两种排序：自然排序和定制排序；默认采用自然排序

### 1.3.1、自然排序
TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列。这就是自然排序。

> java 提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小。当一个对象调用该方法与另一个对象进行比较时，例如obj1.compareTo(obj2)，如果该方法返回0，则表明这两个对象想等；如果返回一个正整数，则表明obj1 大于obj2；返回负整数，表明obj1 小于obj2

实现了Comparable接口的常用类。
1. BigDecimal、BigInteger以及所有的数值型对应的包装类
2. Character：按字符的Unicode值进行比较
3. Boolean：true对应的包装类实例大于false对应的包装类实例
4. String：依次比较字符串中每个字符的Unicode值
5. Date、Time：后面的时间、日期比较前面的时间、日期大

如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则程序将会抛出异常。ClassCastException。==因此TreeSet要求自然排序的集合元素必须都实现Comparable接口。==

> TreeSet只能添加同一种类型的对象。当把一个对象加入TreeSet集合中时，TreeSet调用该对象的compareTo(Object obj)方法与容器中其他对象比较大小，然后根据红黑树结构找到他的存储位置。如果比较想等，新对象将无法添加到TreeSet集合中。

### 1.3.2、定制排序

## 1.4、EnumSet类
EnumSet是一个专为枚举类设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式的指定。EnumSet的集合元素也是有序的，EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序。

EnumSet集合不允许加入null元素，加入null抛出NullPointerException异常。

## 1.5、各Set实现类的性能分析
HashSet的性能总是比TreeSet好（特别是最常用的添加、查询元素等操作），因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要保持一个排序的Set时，才应该使用TreeSet，否则都应该使用HashSet。

HashSet还有一个子类：LinkedHashSet，对于普通的插入、删除操作，LinkedHashSet比HashSet要略微慢一点，这是由维护链表所带来的额外开销造成的，但是由于有了链表，==遍历LinkedHahSet会更快==

HashSet、LinkedHashSet、EnumSet都是线程不安全的。如果有多个线程同时访问一个Set集合，并且有超过一个线程修改了该Set集合，则必须手动==保证该Set集合的同步性通常可以通过Collections工具类的synchronizedSortedSet方法==来包装该Set集合。
```java
SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));
```


# 2、List集合
List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。可以通过索引来访问指定位置的集合元素。List集合默认按元素的添加顺序设置元素的索引。

## 2.1、改进的List接口和ListIterator接口
List接口作为Collection的子接口，可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List增加了一些根据索引来操作集合元素的方法。
1. void add(int index, Object element)：将元素element插入到List集合的index处。
2. boolean addAll(int index, Collection c)：将集合c所包含的所有元素都插入到List集合的index处。
3. Object get(int index)：返回集合index索引处的元素。
4. int indexOf(Object o)：返回对象o在List集合中第一次出现的位置索引。
5. int lastIndexOf(Object o)：返回对象O在List集合中最后一次出现的位置索引
6. Object remove(int index)：删除并返回index索引处的元素。
7. Object set(int index,Object element)：将index索引处的元素替换成element对象，返回被替换的旧元素。
8. List sublist(int fromIndex, int toIndex)：返回从索引fromIndex(包含)到索引toIndex（不包含）处所有的集合元素组成的子集合。
9. void replaceAll(UnaryOperator operator):根据operator指定的计算规则重新设置List集合的所有元素
10. void sort(Comparator c)：根据Comparator参数对List集合的元素排序。

### 2.1.1、ListIterator()方法
ListIterator()方法返回一个ListIterator对象，ListIterator接口继承了Iterator接口，提供了专门操作List的方法。ListIterator在Iterator接口基础上增加了如下方法：
1. boolean hasPrevious():返回迭代器关联的集合是否还有上一个元素。
2. Object previous()：返回迭代器的上一个元素。
3. void add(Object o):在指定位置插入一个元素。
ListIterator增加了向前迭代的功能（Iterator只有向后迭代的功能），而且ListIterator还可通过add()方法向list集合中添加元素（Iterator只能删除元素）。
```java
public static void main(String[] args) {  
    String[] books = {"疯狂java将以","疯狂ios讲义","轻量级Java EE企业级应用实战"};  
    ArrayList<String> bookList = new ArrayList<>();  
    for (int i = 0; i < books.length; i++) {  
        bookList.add(books[i]);  
    }  
    ListIterator<String> lit = bookList.listIterator();  
    //从前向后遍历  
    while(lit.hasNext()){  
        System.out.println(lit.next());  
        lit.add("----分隔符----");  
    }  
    System.out.println("=====开始方向迭代=======");  
    //从后向前遍历  
    while (lit.hasPrevious()){  
        System.out.println(lit.previous());  
    }  
}
```

## 2.2、ArrayList和Vector实现类
ArrayList和Vector类都是基于数组实现的List类，所以ArrayList和Vector类都封装了一个动态的、允许分配的Object[]数组。ArrayList和Vector对象使用initialCapacity参数来设置该数组的长度，当向ArrayList或Vector中添加元素超出了改数组的长度时，它们的initialCapacity会自动增加。

>如果向ArrayList或Vector集合中添加大量元素时，可使用ensureCapacity(int minCapacity)方法一次性增加initialCapacity。这可以减少重分配的次数，从而提高性能。

ArrayList是线程不安全的，Vector是线程安全的，所以Vector的性能要比ArrayList的性能低。
不推荐使用Vector类，因为这是个古老的类，有很多缺点。
## 2.3、固定长度的List
操作数组的工具类：Arrays，该工具类提供了一个把数组或指定个数的对象转换成List集合的方法：asList(Object ... a)，这个List集合不是ArrayList实现类，而是Arrays的内部类ArrayList的实例。

Arrays.ArrayList是一个固定长度的List集合，程序只能遍历该集合里的元素，不可增加、删除集合里的元素。

# 3、Queue集合
Queue用于模拟队列这种数据结构，队列通常是指先进先出（FIFO）的容器。队列头部保存在队列中存放时间最长的元素，队列的尾部保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。
Queue接口中定义了如下几个方法：
1. void add(Object e)：将指定元素加入此队列的尾部。
2. Object element()：获取队列头部的元素，但是不删除该元素。
3. boolean offer(Object e)：将指定元素加入此队列的尾部。
4. Object peek()：获取队列头部的元素，但是不删除该元素。
5. Object poll()：获取队列头部的元素，并删除该元素。
6. Object remove()：获取队列头部的元素，并删除该元素。
Queue接口只有一个PriorityQueue实现类。除此之外，Queue还有一个Deque接口，Deque代表一个“双端队列”，双端队列可以同时从两端来添加、删除元素，因此Deque的实现类即可当成队列使用，也可当成栈使用。

## 3.1、PriorityQueue类
PriorityQueue保存队列元素的顺序并不是按加入队列的顺序，而是按队列元素的大小进行重新排列。因此当调用peek()方法或者poll()方法去除队列中的元素时，并不是去除最先进入队列的元素，而是去除队列中最小的元素。

```java
public static void main(String[] args) {  
    PriorityQueue pq = new PriorityQueue();  
    pq.offer(6);  
    pq.offer(-3);  
    pq.offer(20);  
    pq.offer(18);  
    //输出pq队列，并不是按元素的加入顺序排列  
    System.out.println(pq);//输出[-3, 6, 20, 18]  
    //访问队列的第一个元素，其实就是队列中最小的元素：-3  
    Object peek = pq.peek();  
    System.out.println(peek);//输出-3  
}
```

PriorityQueue的元素有两种排列顺序：自然排序和定制排序；与TreeSet的要求基本一致，都是通过元素实现Comparable接口实现排序的。

## 3.2、Deque接口与ArrayDeque实现类

## 3.3、LinkedList实现类
LinkedList类是List接口的实现类——这意味着它是一个List集合，可以根据索引来随机访问集合中的元素。此外，LinkedList还实现了Deque接口，可以被当成双端队列来使用，因此既可以被当成“栈”来使用，也可以当成队列使用。

ArrayList、ArrayDeque内部一数组的形式来保存集合中的元素，因此==随机访问集合元素时有比较好的性能==；
LinkedList内部以链表的形式来保存集合中的元素，因此==随机访问集合元素时性能较差==，但在==插入、删除元素时性能比较出色==（只需==改变指针所指的地址==即可）。

## 3.4、各种线性表的性能分析
Java提供的List就是一个线性表接口，ArrayList和LinkedList分别是基于数组的线性表和基于链的线性表。
> 由于数组以一块连续内存区来保存所有的数组元素，所以数组在==随机访问时性能最好==；因为插入时涉及到重新分配内部数组的大小，所以性能较差。
> 而内部以链表作为底层实现的集合在执行==插入、删除==操作时有较好的性能


# 4、增强的Map集合
Map用于保存具有映射关系的数据，因此Map集合里保存这两组值，一组值key,一组值value。key和value都可以是任何引用类型的数据。
Map接口定义了如下常用方法：
1. boolean containsValue(Object value)：查询Map中是否包含一个或多个value，如果包含则返回true
2. Set entrySet()：返回Map中包含的key-value所组成的Set集合，每个集合元素都是Map.Entry(Entry是Map的内部类)对象。
3. Set keySet():返回该Map所有key组成的Set集合。
4. void putAll(Map m)：将指定Map中所有的key-value对复制到本Map中

Map中包含一个内部类Entry,该类封装了一个Key-value对。Entry包含如下三个方法。
1. Object getKey():
2. Object getValue():
3. Object setValue(V value): 设置该Entry里包含的value值，并返回新设置的value值。

## 4.1、Java8为Map新增的方法

## 4.2、改进的HashMap和HashTable实现类
HashMap和HashTable的区别：
1. HashTable是一个线程安全的Map实现，但HashMap不是线程安全的实现。
2. HashTable不允许使用null作为key和value，但HashMap可以使用null作为key或value。
## 4.3、LinkedHashMap实现类
LinkedHashMap也使用双向链表来维护key-value对的顺序（其实只考虑key的顺序）,该链表负责维护Map的迭代顺序，迭代顺序与key-value对的插入顺序保持一致。

LinkedHashMap需要维护元素插入的顺序， 因此性能略低于HashMap的性能；但因为它以链表来维护内部顺序，所以在迭代访问Map里面的全部元素时将有较好的性能。

## 4.4、使用Properties读写属性文件
Properties类时hashtable的子类，该对象在处理属性文件时特别方便。Properties类可以吧Map对象和属性文件关联起来，从而可以吧Map对象中的key-value对写入属性文件中，也可以把属性文件中的”属性名=属性值“加载到Map对象中。由于属性文件中的属性名、属性值只能是字符串类型的，所以Properties里的key、value都是字符串类型的。
Properties的三个方法：
1. String getProperty(String key)
2. String getProperty(String key, String defaultValue)
3. Object setProperty(String key, String value)
除此之外，它还提供了两个读写属性文件的方法。
1. void load(InputStream inStream)：从属性文件中加载key-value对，把加载到的key-value对追加到Properties里
2. void store(OutputStream out, String comments):将Properties中的key-value对输出到指定属性文件（以输出流表示）中。

## 4.5、SortedMap接口和TreeMap实现类
TreeMap就是一个红黑树结构，每个key-value对即作为红黑树的一个节点。TreeMap存储key-value对（节点）时，需要根据key对节点进行排序。TreeMap可以保证所有的key-value对处于有序状态。TreeMap也有两种排序方式。

自然排序：TreeMap的所有key必须实现Comparable接口，而且所有的key应该是同一个类的对象，否则将会抛出ClassCastException异常。
定制排序：创建TreeMap时，传入一个Comparator对象，该对象负责TreeMap中的所有key进行排序。

## 4.6、WeakHashMap实现类
WeakHashMap的key只保留了对实际对象的弱应用，这意味着如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，WeakHashMap也可能自动删除这些key所对应的key-value对。

## 4.7、IdentityHashMap实现类
在IdentityHashMap中，当且仅当两个key严格相等（key1 == key2)时，IdentityHashMap才认为两个key相等；对于普通的HashMap而言，只要key1和key2通过equals()方法比较返回true，且它们的hashCode值相等即可。

## 4.8、EnumMap实现类

## 4.9、各Map实现类的性能分析
对于Map的常用实现类而言，虽然HashMap和hashtable的实现机制几乎一样，但是由于hashtable是一个古老的线程安全的集合，因此HashMap通常比Hashtable要快。

TreeMap通常比HashMap、hashtable要慢（尤其在插入、删除key-value对时更慢），因为TreeMap底层采用红黑树来管理key-value对（红黑树的每个节点就是一个key-value对）。

使用TreeMap又一个好处：TreeMap中的key-value对总是处于有序状态，无须专门进行排序操作。当TreeMap被填充之后，就可以调用keySet()，取得由key组成的Set，然后使用toArray()方法生成key的数组，接下来使用Arrays的binarySearch()方法在一排序的数组中快速地查询对象。



